---
// src/components/preferences/language/BrowserTranslateScript.astro
/**
 * Hybrid Browser Translation Script
 *
 * Uses Chrome's Translator API (138+) / Edge (143+) when available.
 * Falls back to Google Translate SDK for other browsers (requires functional consent).
 *
 * Features:
 * - Native API for desktop Chrome/Edge (fastest, offline capable, no consent needed)
 * - Google Translate SDK fallback for mobile & other browsers (requires consent)
 * - MutationObserver to translate dynamically added content (React components)
 * - Original text storage for reversion
 *
 * Props:
 * - enableNative: boolean (default: true) - Enable Chrome/Edge native Translator API
 * - enableGoogle: boolean (default: true) - Enable Google Translate SDK fallback
 */

export interface Props {
  enableNative?: boolean;
  enableGoogle?: boolean;
}

const {
  enableNative = true,
  enableGoogle = true
} = Astro.props;
---
<script is:inline define:vars={{ enableNative, enableGoogle }}>
(function() {
  var STORAGE_KEY = "user-language";
  var CONSENT_COOKIE = "cookie-consent";

  // Configuration from props
  var CONFIG = {
    enableNative: enableNative,
    enableGoogle: enableGoogle
  };

  var state = {
    currentLanguage: "en",
    translator: null,
    isTranslating: false,
    translationMethod: 'none', // 'native' | 'google' | 'none'
    originalTexts: new WeakMap(),
    translatedNodes: new WeakSet(),
    pendingNodes: new Set(),
    translateTimeout: null,
    observer: null,
    googleInitialized: false,
    googleScriptRequested: false,
    pendingGoogleLanguage: null,
    config: CONFIG,
  };

  window.__browserTranslation = state;

  function getStoredLanguage() {
    try {
      return localStorage.getItem(STORAGE_KEY) || "en";
    } catch (e) {
      return "en";
    }
  }

  function setStoredLanguage(code) {
    try {
      localStorage.setItem(STORAGE_KEY, code);
    } catch (e) {}
  }

  // Check for functional consent from cookie
  function hasFunctionalConsent() {
    try {
      var cookies = document.cookie.split(';');
      for (var i = 0; i < cookies.length; i++) {
        var cookie = cookies[i].trim();
        if (cookie.indexOf(CONSENT_COOKIE + '=') === 0) {
          var value = decodeURIComponent(cookie.substring(CONSENT_COOKIE.length + 1));
          var consent = JSON.parse(value);
          return consent && consent.functional === true;
        }
      }
    } catch (e) {}
    return false;
  }

  // ============================================
  // Chrome Translator API (Native)
  // ============================================

  function hasTranslatorAPI() {
    // Check if native is enabled via config AND browser supports it
    return CONFIG.enableNative && typeof window !== "undefined" && "Translator" in window;
  }

  async function checkLanguageSupport(targetLang) {
    if (!hasTranslatorAPI() || !window.Translator) return false;

    try {
      var availability = await window.Translator.availability({
        sourceLanguage: "en",
        targetLanguage: targetLang,
      });
      return availability === "available" || availability === "downloadable" || availability === "downloading";
    } catch (e) {
      return false;
    }
  }

  async function createTranslator(targetLang) {
    if (!hasTranslatorAPI() || !window.Translator) return null;

    try {
      var translator = await window.Translator.create({
        sourceLanguage: "en",
        targetLanguage: targetLang,
      });
      return translator;
    } catch (error) {
      return null;
    }
  }

  // ============================================
  // Google Translate SDK (Fallback with consent)
  // ============================================

  function setCookie(name, value, days) {
    var expires = "";
    if (days) {
      var date = new Date();
      date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
      expires = "; expires=" + date.toUTCString();
    }
    document.cookie = name + "=" + (value || "") + expires + "; path=/; SameSite=Lax";
  }

  function clearCookie(name) {
    document.cookie = name + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
  }

  function ensureGoogleTranslateScript() {
    // Check if Google Translate is enabled via config
    if (!CONFIG.enableGoogle) return;
    if (state.googleScriptRequested || state.googleInitialized) return;
    if (!hasFunctionalConsent()) return;

    var existing = document.getElementById("google-translate-sdk");
    if (existing) {
      state.googleScriptRequested = true;
      return;
    }

    state.googleScriptRequested = true;

    // Create hidden container for Google Translate
    var el = document.getElementById('google_translate_element');
    if (!el) {
      el = document.createElement('div');
      el.id = 'google_translate_element';
      el.style.display = 'none';
      document.body.appendChild(el);
    }

    var script = document.createElement("script");
    script.id = "google-translate-sdk";
    script.src = "https://translate.google.com/translate_a/element.js?cb=initializeGoogleTranslate";
    script.async = true;
    script.onerror = function() { state.googleScriptRequested = false; };
    document.head.appendChild(script);
  }

  window.initializeGoogleTranslate = function() {
    var google = window.google;
    if (!google || !google.translate || !google.translate.TranslateElement) {
      state.googleScriptRequested = false;
      return;
    }

    new google.translate.TranslateElement(
      { pageLanguage: "en", includedLanguages: "", autoDisplay: false },
      "google_translate_element"
    );

    state.googleInitialized = true;
    state.translationMethod = 'google';

    // Apply pending language if any
    var desiredLanguage = state.pendingGoogleLanguage || getStoredLanguage();
    if (desiredLanguage && desiredLanguage !== "en") {
      requestAnimationFrame(function() { applyGoogleLanguage(desiredLanguage); });
    }
  };

  function applyGoogleLanguage(languageCode) {
    var combo = document.querySelector("select.goog-te-combo");
    if (!(combo instanceof HTMLSelectElement)) return false;

    var normalized = languageCode === "en" ? "" : languageCode;
    if (combo.value === normalized) {
      state.pendingGoogleLanguage = null;
      return true;
    }

    combo.value = normalized;
    combo.dispatchEvent(new Event("change"));

    if (normalized) {
      document.documentElement.dataset.preferredLanguage = languageCode;
      document.documentElement.lang = languageCode;
    } else {
      document.documentElement.removeAttribute("data-preferred-language");
      document.documentElement.lang = "en";
    }

    state.currentLanguage = languageCode;
    state.pendingGoogleLanguage = null;
    return true;
  }

  function persistGoogleCookie(languageCode) {
    if (!hasFunctionalConsent()) {
      if (languageCode === "en") clearCookie("googtrans");
      return;
    }

    if (languageCode === "en") {
      clearCookie("googtrans");
    } else {
      setCookie("googtrans", "/en/" + languageCode, 365);
    }
  }

  // ============================================
  // Native Translation (Chrome/Edge)
  // ============================================

  function shouldTranslateNode(node) {
    var parent = node.parentElement;
    if (!parent) return false;

    var tagName = parent.tagName.toLowerCase();
    // Skip script, style, and form elements
    if (tagName === "script" || tagName === "style" || tagName === "noscript" || tagName === "textarea" || tagName === "input") {
      return false;
    }

    // Skip SVG elements entirely (icons)
    if (parent.closest("svg") || tagName === "svg") {
      return false;
    }

    // Skip elements marked as notranslate
    if (parent.closest(".notranslate, [translate='no']")) {
      return false;
    }

    // Skip screen reader only text (sr-only class) - these are for accessibility
    if (parent.classList && parent.classList.contains("sr-only")) {
      return false;
    }

    // Skip icon containers, tech stack items, and emoji icons
    if (parent.closest("[data-tech-item], [data-icon], .iconify, [aria-hidden='true'], [role='img']")) {
      return false;
    }

    // Skip if parent is a button with only an icon (no meaningful text)
    if (parent.closest("button") && parent.closest("svg, [role='img'], .iconify")) {
      return false;
    }

    var text = node.textContent ? node.textContent.trim() : "";
    if (!text || text.length < 2) {
      return false;
    }

    if (state.translatedNodes.has(node)) {
      return false;
    }

    return true;
  }

  function getTranslatableNodes(root) {
    root = root || document.body;
    var walker = document.createTreeWalker(
      root,
      NodeFilter.SHOW_TEXT,
      {
        acceptNode: function(node) {
          return shouldTranslateNode(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
        },
      }
    );

    var nodes = [];
    var node;
    while ((node = walker.nextNode())) {
      nodes.push(node);
    }
    return nodes;
  }

  async function translateNodesNative(nodes) {
    if (!state.translator || nodes.length === 0) return;

    var batchSize = 10;
    for (var i = 0; i < nodes.length; i += batchSize) {
      var batch = nodes.slice(i, i + batchSize);

      await Promise.all(
        batch.map(async function(node) {
          if (!node.parentElement || state.translatedNodes.has(node)) return;

          var originalText = node.textContent || "";
          if (!originalText.trim()) return;

          if (!state.originalTexts.has(node)) {
            state.originalTexts.set(node, originalText);
          }

          try {
            var translated = await state.translator.translate(originalText);
            if (translated && translated !== originalText && node.parentElement) {
              node.textContent = translated;
              state.translatedNodes.add(node);
            }
          } catch (error) {
            // Individual translation failed, keep original
          }
        })
      );
    }
  }

  function schedulePendingTranslation() {
    if (state.translateTimeout) {
      clearTimeout(state.translateTimeout);
    }

    state.translateTimeout = setTimeout(async function() {
      if (state.pendingNodes.size === 0) return;
      if (state.translationMethod !== 'native') return;

      var nodes = Array.from(state.pendingNodes);
      state.pendingNodes.clear();

      var validNodes = nodes.filter(function(n) { return n.parentElement && shouldTranslateNode(n); });
      if (validNodes.length === 0) return;

      if (state.translator) {
        await translateNodesNative(validNodes);
      }
    }, 150);
  }

  function setupMutationObserver() {
    if (state.observer) return;

    state.observer = new MutationObserver(function(mutations) {
      if (state.currentLanguage === "en" || state.translationMethod !== 'native') return;

      for (var i = 0; i < mutations.length; i++) {
        var mutation = mutations[i];

        for (var j = 0; j < mutation.addedNodes.length; j++) {
          var addedNode = mutation.addedNodes[j];
          if (addedNode.nodeType === Node.TEXT_NODE) {
            if (shouldTranslateNode(addedNode)) {
              state.pendingNodes.add(addedNode);
            }
          } else if (addedNode.nodeType === Node.ELEMENT_NODE) {
            var textNodes = getTranslatableNodes(addedNode);
            for (var k = 0; k < textNodes.length; k++) {
              state.pendingNodes.add(textNodes[k]);
            }
          }
        }

        if (mutation.type === "characterData" && mutation.target.nodeType === Node.TEXT_NODE) {
          var node = mutation.target;
          if (!state.translatedNodes.has(node) && shouldTranslateNode(node)) {
            state.pendingNodes.add(node);
          }
        }
      }

      if (state.pendingNodes.size > 0) {
        schedulePendingTranslation();
      }
    });

    state.observer.observe(document.body, {
      childList: true,
      subtree: true,
      characterData: true,
    });
  }

  function stopMutationObserver() {
    if (state.observer) {
      state.observer.disconnect();
      state.observer = null;
    }
    state.pendingNodes.clear();
    if (state.translateTimeout) {
      clearTimeout(state.translateTimeout);
      state.translateTimeout = null;
    }
  }

  async function translatePageNative(targetLang) {
    state.isTranslating = true;
    document.documentElement.dataset.translating = "true";

    try {
      var isSupported = await checkLanguageSupport(targetLang);
      if (!isSupported) return false;

      var translator = await createTranslator(targetLang);
      if (!translator) return false;

      state.translator = translator;
      state.translationMethod = 'native';
      state.currentLanguage = targetLang;

      var nodes = getTranslatableNodes();
      await translateNodesNative(nodes);

      setupMutationObserver();

      document.documentElement.lang = targetLang;
      document.documentElement.dataset.preferredLanguage = targetLang;

      return true;
    } catch (error) {
      return false;
    } finally {
      state.isTranslating = false;
      delete document.documentElement.dataset.translating;
    }
  }

  function revertNativeTranslations() {
    stopMutationObserver();

    var walker = document.createTreeWalker(document.body, NodeFilter.SHOW_TEXT);
    var node;
    while ((node = walker.nextNode())) {
      var original = state.originalTexts.get(node);
      if (original !== undefined) {
        node.textContent = original;
        state.originalTexts.delete(node);
      }
    }

    state.translatedNodes = new WeakSet();
    state.translator = null;
  }

  // ============================================
  // Main Translation Logic
  // ============================================

  async function translatePage(targetLang) {
    if (state.isTranslating) return;

    if (targetLang === "en") {
      // Revert to English
      if (state.translationMethod === 'native') {
        revertNativeTranslations();
      } else if (state.translationMethod === 'google' && state.googleInitialized) {
        applyGoogleLanguage("en");
        clearCookie("googtrans");
      }
      state.currentLanguage = "en";
      state.translationMethod = 'none';
      document.documentElement.lang = "en";
      document.documentElement.removeAttribute("data-preferred-language");
      return;
    }

    // Try native Translator API first (Chrome/Edge - no consent needed)
    if (hasTranslatorAPI()) {
      var success = await translatePageNative(targetLang);
      if (success) {
        return;
      }
    }

    // Fall back to Google Translate SDK (requires functional consent)
    if (CONFIG.enableGoogle && hasFunctionalConsent()) {
      state.pendingGoogleLanguage = targetLang;
      persistGoogleCookie(targetLang);

      if (state.googleInitialized) {
        applyGoogleLanguage(targetLang);
      } else {
        ensureGoogleTranslateScript();
      }
    } else if (CONFIG.enableGoogle && !hasFunctionalConsent()) {
      // Google enabled but no consent - dispatch event so UI can prompt user
      window.dispatchEvent(new CustomEvent('translation-needs-consent', {
        detail: { language: targetLang }
      }));
    }
    // If neither native nor Google is available/enabled, translation silently fails
  }

  // Initialize - page always loads in English first
  // Translation only happens when user explicitly changes language
  function init() {
    // Don't auto-translate on page load - let page render in English first
    // User's saved preference will be applied when they interact with the dropdown
    // This prevents the flicker/blocking that Google Translate causes
  }

  // Expose changeLanguage globally
  window.changeLanguage = function(languageCode) {
    var code = languageCode || "en";
    setStoredLanguage(code);

    if (!document.body) {
      document.addEventListener("DOMContentLoaded", function() {
        translatePage(code);
      });
      return;
    }

    translatePage(code);
  };

  // Expose helpers for UI components
  window.translationNeedsConsent = function() {
    // Returns true if translation will need Google (i.e., no native API available/enabled)
    return !hasTranslatorAPI();
  };

  window.getTranslationMethod = function() {
    return state.translationMethod;
  };

  window.getTranslationConfig = function() {
    return CONFIG;
  };

  window.isTranslationAvailable = function() {
    // Returns true if at least one translation method is enabled and available
    var nativeAvailable = CONFIG.enableNative && typeof window !== "undefined" && "Translator" in window;
    var googleAvailable = CONFIG.enableGoogle;
    return nativeAvailable || googleAvailable;
  };

  window.hasFunctionalConsent = hasFunctionalConsent;

  // Listen for consent changes
  window.addEventListener("consent-changed", function() {
    if (!hasFunctionalConsent()) return;
    var preferred = getStoredLanguage();
    if (preferred === "en") return;

    // If we're not using native, try Google now that we have consent
    if (state.translationMethod !== 'native') {
      state.pendingGoogleLanguage = preferred;
      persistGoogleCookie(preferred);
      if (state.googleInitialized) {
        applyGoogleLanguage(preferred);
      } else {
        ensureGoogleTranslateScript();
      }
    }
  });

  // Run init after DOM is ready
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", init);
  } else {
    init();
  }
})();
</script>

<div id="google_translate_element" style="display: none;"></div>

<style>
  /* Show subtle indicator while translating */
  html[data-translating="true"] body {
    cursor: progress;
  }

  /* Hide Google Translate UI elements */
  .goog-te-banner-frame,
  .goog-te-balloon-frame,
  .goog-te-gadget,
  .skiptranslate,
  iframe.goog-te-menu-frame,
  #google_translate_element,
  body > .skiptranslate,
  iframe.skiptranslate {
    display: none !important;
  }

  body {
    top: 0 !important;
  }

  /* Ensure notranslate elements are respected */
  .notranslate,
  [translate="no"] {
    /* These are handled in JS, but this provides a CSS hook if needed */
  }
</style>
